{"version":3,"file":"PMREMGenerator.js","sourceRoot":"","sources":["../../src/three-components/PMREMGenerator.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {BoxBufferGeometry, CubeCamera, CubeUVReflectionMapping, DoubleSide, Material, Mesh, NearestFilter, NoBlending, OrthographicCamera, PlaneBufferGeometry, RawShaderMaterial, Scene, WebGLRenderer, WebGLRenderTarget, WebGLRenderTargetCube} from 'three';\n\nimport {IS_IE11} from '../constants.js';\n\nimport {encodings, getDirectionChunk, getFaceChunk, texelIO} from './shader-chunk/common.glsl.js';\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the lodMin level (below), and then creates extra\n * even more filtered mips at the same lodMin resolution, associated with higher\n * roughness levels. These extra mips are stored at X rather than Y offsets to\n * help distiguish them. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n */\nexport const generatePMREM =\n    (cubeTarget: WebGLRenderTargetCube, renderer: WebGLRenderer):\n        WebGLRenderTarget => {\n          const extraLodsRoughness = [0.5, 0.7, 1.0];\n          const {cubeUVRenderTarget, cubeLods, meshes} =\n              setup(cubeTarget, extraLodsRoughness);\n          // This hack is necessary for now because CubeUV is not really a\n          // first-class citizen within the Standard material yet, and it does\n          // not seem to be easy to add new uniforms to existing materials.\n          renderer.properties.get(cubeUVRenderTarget.texture).__maxMipLevel =\n              cubeLods.length;\n\n          generateMipmaps(cubeTarget, cubeLods, renderer);\n          packMipmaps(cubeUVRenderTarget, meshes, renderer);\n\n          cubeLods.forEach((target) => {\n            target.dispose();\n          });\n          meshes.forEach((mesh) => {\n            (mesh.material as Material).dispose();\n            mesh.geometry.dispose();\n          });\n\n          return cubeUVRenderTarget;\n        };\n\nconst setup =\n    (cubeTarget: WebGLRenderTargetCube, extraLodsRoughness: Array<number>) => {\n      const extraLods = extraLodsRoughness.length;\n      const params = {\n        format: cubeTarget.texture.format,\n        magFilter: NearestFilter,\n        minFilter: NearestFilter,\n        type: cubeTarget.texture.type,\n        generateMipmaps: false,\n        anisotropy: cubeTarget.texture.anisotropy,\n        encoding: cubeTarget.texture.encoding\n      };\n\n      // Hard-coded to lodMax = 8 until we can add a uniform.\n      const lodMin = 3;\n      const lodMax = 8;\n      // lodBase is the mip Level that is integrated to form all of the extra\n      // levels, but is not output directly into the PMREM texture. DO NOT\n      // CHANGE, as the Blur shader below is hard coded for this size.\n      const lodBase = 2;\n\n      // Math.log(cubeTarget.width) / Math.log(2) - 2;  // IE11 doesn't support\n      // Math.log2\n\n      const cubeLods: Array<WebGLRenderTargetCube> = [];\n      const meshes: Array<Mesh> = [];\n\n      for (let i = lodBase; i < lodMax; i++) {\n        const sizeLod = Math.pow(2, i);\n        const renderTarget =\n            new WebGLRenderTargetCube(sizeLod, sizeLod, params);\n        renderTarget.texture.name = 'PMREMGenerator.cube' + i;\n        cubeLods.push(renderTarget);\n      }\n\n      let offsetY = 0;\n      const sizeMin = Math.pow(2, lodMin) + 2;\n      const sizeMax = Math.pow(2, lodMax) + 2;\n      for (let lod = lodMin; lod <= lodMax; lod++) {\n        const sizeLod = Math.pow(2, lod);\n        let offsetX = 0;\n        const nExtra = lod == lodMin ? extraLods : 0;\n        for (let i = 0; i <= nExtra; ++i) {\n          const target = lod == lodMax ?\n              cubeTarget :\n              i > 0 ? cubeLods[0] : cubeLods[lod - lodBase];\n          const roughness = i > 0 ? extraLodsRoughness[i - 1] : 0;\n          appendLodMeshes(meshes, target, sizeLod, offsetX, offsetY, roughness);\n          offsetX += 3 * sizeMin;\n        }\n        offsetY += 2 * (sizeLod + 2);\n      }\n\n      const cubeUVRenderTarget =\n          new WebGLRenderTarget(3 * sizeMax, offsetY, params);\n      cubeUVRenderTarget.texture.name = 'PMREMCubeUVPacker.cubeUv';\n      cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n\n      return {cubeUVRenderTarget, cubeLods, meshes};\n    };\n\nconst appendLodMeshes =\n    (meshes: Array<Mesh>,\n     target: WebGLRenderTargetCube,\n     sizeLod: number,\n     offsetX: number,\n     offsetY: number,\n     roughness: number) => {\n      // We pad each face with a one pixel boarder. By duplicating these points\n      // from the neighboring faces we make the texture interpolation for the\n      // output renderer much simpler and more GPU cache-friendly.\n      const sizePad = sizeLod + 2;\n      const texelSize = 1.0 / sizeLod;\n      const plane = new PlaneBufferGeometry(1, 1);\n      const uv = (plane.attributes.uv.array as Array<number>);\n      for (let i = 0; i < uv.length; i++) {\n        if (uv[i] === 0) {\n          uv[i] = -texelSize;\n        } else {  // == 1\n          uv[i] = 1 + texelSize;\n        }\n      }\n      for (let i = 0; i < 6; i++) {\n        // 6 Cube Faces\n        const material =\n            roughness !== 0 ? new BlurShader() : new PackingShader();\n        if (roughness !== 0) {\n          const sigma = Math.PI * roughness * roughness / (1 + roughness);\n          material.uniforms.sigma.value = sigma;\n        }\n\n        material.uniforms.texelSize.value = texelSize;\n        material.uniforms.envMap.value = target.texture;\n        material.uniforms.inputEncoding.value =\n            encodings[target.texture.encoding];\n        material.uniforms.outputEncoding.value =\n            encodings[target.texture.encoding];\n        material.uniforms.faceIndex.value = i;\n\n        const planeMesh = new Mesh(plane, material);\n\n        planeMesh.position.x = (0.5 + (i % 3)) * sizePad + offsetX;\n        planeMesh.position.y = (0.5 + (i > 2 ? 1 : 0)) * sizePad + offsetY;\n        (planeMesh.material as Material).side = DoubleSide;\n        planeMesh.scale.setScalar(sizePad);\n        meshes.push(planeMesh);\n      }\n    };\n\nconst generateMipmaps =\n    (cubeTarget: WebGLRenderTargetCube,\n     cubeLods: Array<WebGLRenderTargetCube>,\n     renderer: WebGLRenderer) => {\n      const cubeCamera = new CubeCamera(0.1, 100, 1);\n      cubeCamera.renderTarget.dispose();\n      let mipmapShader = new MipmapShader();\n      const mipmapScene = new Scene();\n      const boxMesh = new Mesh(new BoxBufferGeometry(), mipmapShader);\n      (boxMesh.material as Material).side = DoubleSide;\n      mipmapScene.add(boxMesh);\n\n      mipmapShader.uniforms.texelSize.value = 1.0 / cubeTarget.width;\n      mipmapShader.uniforms.envMap.value = cubeTarget.texture;\n      mipmapShader.uniforms.inputEncoding.value =\n          encodings[cubeTarget.texture.encoding];\n      for (let i = cubeLods.length - 1; i >= 0; i--) {\n        const {uniforms} = mipmapShader;\n        cubeCamera.renderTarget = cubeLods[i];\n        uniforms.outputEncoding.value = encodings[cubeLods[i].texture.encoding];\n        cubeCamera.update(renderer, mipmapScene);\n        uniforms.texelSize.value = 1.0 / cubeLods[i].width;\n        uniforms.envMap.value = cubeLods[i].texture;\n        uniforms.inputEncoding.value = encodings[cubeLods[i].texture.encoding];\n      }\n    };\n\nconst packMipmaps =\n    (cubeUVRenderTarget: WebGLRenderTarget,\n     meshes: Array<Mesh>,\n     renderer: WebGLRenderer) => {\n      const packingScene = new Scene();\n      meshes.forEach((mesh) => {\n        packingScene.add(mesh);\n      });\n      const flatCamera = new OrthographicCamera(\n          0, cubeUVRenderTarget.width, 0, cubeUVRenderTarget.height, 0, 1);\n\n      renderer.setRenderTarget(cubeUVRenderTarget);\n      renderer.render(packingScene, flatCamera);\n    };\n\nconst commonVertexShader = `\nprecision mediump float;\nprecision mediump int;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nattribute vec3 position;\nattribute vec2 uv;\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvoid main() {\n    vUv = uv;\n    vPosition = position;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`;\n\nclass MipmapShader extends RawShaderMaterial {\n  constructor() {\n    super({\n\n      uniforms: {\n        texelSize: {value: 0.5},\n        envMap: {value: null},\n        inputEncoding: {value: 2},\n        outputEncoding: {value: 2},\n      },\n\n      vertexShader: commonVertexShader,\n\n      fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec2 vUv;\nvarying vec3 vPosition;\nuniform float texelSize;\nuniform samplerCube envMap;\n${getFaceChunk}\n${getDirectionChunk}\n${texelIO}\nvoid main() {\n  int face = getFace(vPosition);\n  vec2 uv = vUv - 0.5 * texelSize;\n  vec3 texelDir = getDirection(uv, face);\n  vec3 color = inputTexelToLinear(textureCube(envMap, texelDir)).rgb;\n  uv.x += texelSize;\n  texelDir = getDirection(uv, face);\n  color += inputTexelToLinear(textureCube(envMap, texelDir)).rgb;\n  uv.y += texelSize;\n  texelDir = getDirection(uv, face);\n  color += inputTexelToLinear(textureCube(envMap, texelDir)).rgb;\n  uv.x -= texelSize;\n  texelDir = getDirection(uv, face);\n  color += inputTexelToLinear(textureCube(envMap, texelDir)).rgb;\n  gl_FragColor = linearToOutputTexel(vec4(color * 0.25, 1.0));\n}\n`,\n\n      blending: NoBlending\n\n    });\n\n    this.type = 'PMREMGenerator';\n  }\n}\n\n// This is a hack because IE claims that a shader which unrolls a loop to access\n// 96 texture lookups has \"complexity which exceeds allowed limits\", however 48\n// seems to be fine, so we subsample. This could be improved if someone cares a\n// lot about IE.\nconst IE11 = IS_IE11 ? '#define IE11' : '';\n\nclass BlurShader extends RawShaderMaterial {\n  constructor() {\n    super({\n\n      uniforms: {\n        sigma: {value: 0.5},\n        texelSize: {value: 0.5},\n        envMap: {value: null},\n        faceIndex: {value: 0},\n        inputEncoding: {value: 2},\n        outputEncoding: {value: 2},\n      },\n\n      vertexShader: commonVertexShader,\n\n      fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec2 vUv;\nvarying vec3 vPosition;\nuniform float sigma;\nuniform float texelSize;\nuniform samplerCube envMap;\nuniform int faceIndex;\n#define sourceTexelSize 0.5\n${IE11}\n${getDirectionChunk}\n${texelIO}\nvec4 accumulate(vec4 soFar, vec3 outputDir, vec3 sampleDir) {\n  float weight = 1.0 - smoothstep(0.0, sigma, acos(dot(sampleDir, outputDir)));\n  if (weight > 0.0) {\n    soFar += weight * inputTexelToLinear(textureCube(envMap, sampleDir));\n  }\n  return soFar;\n}\nvec4 accumulateFaces(vec4 soFar, vec3 outputDir, vec3 sampleDir) {\n  soFar = accumulate(soFar, outputDir, sampleDir);\n  soFar = accumulate(soFar, outputDir, -sampleDir);\n  soFar = accumulate(soFar, outputDir, sampleDir.xzy);\n  soFar = accumulate(soFar, outputDir, -sampleDir.xzy);\n  soFar = accumulate(soFar, outputDir, sampleDir.zxy);\n  soFar = accumulate(soFar, outputDir, -sampleDir.zxy);\n  return soFar;\n}\nvoid main() {\n  vec2 uv = vUv;\n  if ((vUv.x < 0.0 || vUv.x > 1.0) && (vUv.y < 0.0 || vUv.y > 1.0)) {\n    // The corner pixels do not represent any one face, so to get consistent\n    // interpolation, they must average the three neighboring face corner\n    // pixels, here approximated by sampling exactly at the corner.\n    uv -= 0.5 * texelSize * sign(vUv);\n  }\n  vec3 outputDir = normalize(getDirection(uv, faceIndex));\n  vec4 color = vec4(0.0);\n  for (float x = 0.5 * sourceTexelSize; x < 1.0; x += sourceTexelSize) {\n#ifndef IE11\n    for (float y = 0.5 * sourceTexelSize; y < 1.0; y += sourceTexelSize) {\n      vec3 sampleDir = normalize(vec3(x, y, 1.0));\n#else\n      vec3 sampleDir = normalize(vec3(x, x, 1.0));\n#endif\n      color = accumulateFaces(color, outputDir, sampleDir);\n      sampleDir.x *= -1.0;\n      color = accumulateFaces(color, outputDir, sampleDir);\n      sampleDir.y *= -1.0;\n      color = accumulateFaces(color, outputDir, sampleDir);\n      sampleDir.x *= -1.0;\n      color = accumulateFaces(color, outputDir, sampleDir);\n#ifndef IE11\n    }\n#endif\n  }\n  gl_FragColor = linearToOutputTexel(color / color.a);\n}\n`,\n\n      blending: NoBlending\n\n    });\n\n    this.type = 'PMREMGeneratorBlur';\n  }\n}\n\nclass PackingShader extends RawShaderMaterial {\n  constructor() {\n    super({\n\n      uniforms: {\n        texelSize: {value: 0.5},\n        envMap: {value: null},\n        faceIndex: {value: 0},\n        inputEncoding: {value: 2},\n        outputEncoding: {value: 2},\n      },\n\n      vertexShader: commonVertexShader,\n\n      fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec2 vUv;\nuniform float texelSize;\nuniform samplerCube envMap;\nuniform int faceIndex;\n${getDirectionChunk}\n${texelIO}\nvoid main() {\n    if ((vUv.x >= 0.0 && vUv.x <= 1.0) || (vUv.y >= 0.0 && vUv.y <= 1.0)) {\n      // By using UV coordinates that go past [0, 1], textureCube automatically \n      // grabs our neighboring face values for our padded edge.\n      vec3 direction = getDirection(vUv, faceIndex);\n      gl_FragColor = textureCube(envMap, direction);\n    } else {\n      // The corner pixels do not represent any one face, so to get consistent \n      // interpolation, they must average the three neighboring face corners.\n      vec2 uv = vUv;\n      uv.x += vUv.x < 0.0 ? texelSize : -texelSize;\n      vec3 direction = getDirection(uv, faceIndex);\n      vec3 color = inputTexelToLinear(textureCube(envMap, direction)).rgb;\n      uv.y += vUv.y < 0.0 ? texelSize : -texelSize;\n      direction = getDirection(uv, faceIndex);\n      color += inputTexelToLinear(textureCube(envMap, direction)).rgb;\n      uv.x = vUv.x;\n      direction = getDirection(uv, faceIndex);\n      color += inputTexelToLinear(textureCube(envMap, direction)).rgb;\n      gl_FragColor = linearToOutputTexel(vec4(color / 3.0, 1.0));\n    }\n}\n`,\n\n      blending: NoBlending\n\n    });\n\n    this.type = 'PMREMCubeUVPacker';\n  }\n}\n"]}