{"version":3,"file":"cube_uv_reflection_fragment.glsl.js","sourceRoot":"","sources":["../../../src/three-components/shader-chunk/cube_uv_reflection_fragment.glsl.js"],"names":[],"mappings":"AAAA,OAAO,EAAC,YAAY,EAAE,UAAU,EAAC,MAAM,kBAAkB,CAAC;AAE1D,MAAM,CAAC,MAAM,WAAW,GAAG,UAAU,CAAC;;;;;;;;EAQpC,YAAY;EACZ,UAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqEX,CAAC","sourcesContent":["import {getFaceChunk, getUVChunk} from './common.glsl.js';\n\nexport const cubeUVChunk = /* glsl */ `\n#ifdef ENVMAP_TYPE_CUBE_UV\n\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 3.0\n#define cubeUV_sizeY(maxMip) (4.0 * (maxMip + exp2(maxMip)) + 2.0)\n#define cubeUV_margin cubeUV_sizeY(cubeUV_minMipLevel - 1.0)\n\n${getFaceChunk}\n${getUVChunk}\n\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  int face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n\n  vec2 texelSize = 1.0 / vec2(\n              3.0 * (exp2(cubeUV_maxMipLevel) + 2.0),\n              cubeUV_sizeY(cubeUV_maxMipLevel) - cubeUV_margin);\n\n  vec2 uv = getUV(direction, face) * faceSize;\n  uv += 0.5;\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2) {\n    uv.y += faceSize + 2.0;\n    face -= 3;\n  }\n  uv.x += float(face) * (faceSize + 2.0);\n  uv.y += cubeUV_sizeY(mipInt - 1.0) - cubeUV_margin;\n  uv.x += filterInt * 3.0 * (exp2(cubeUV_minMipLevel) + 2.0);\n  uv *= texelSize;\n  uv.y = 1.0 - uv.y;\n\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize.x;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y -= texelSize.y;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize.x;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float filterMip = 0.0;\n  if (roughness >= 0.7) {\n    filterMip = (1.0 - roughness) / (1.0 - 0.7) - 3.0;\n  } else if (roughness >= 0.5) {\n    filterMip = (0.7 - roughness) / (0.7 - 0.5) - 2.0;\n  } else if (roughness >= 0.32) {\n    filterMip = (0.5 - roughness) / (0.5 - 0.32) - 1.0;\n  }\n\n  roughness = min(roughness, 0.32);\n  float sigma = PI * roughness * roughness / (1.0 + roughness);\n\n  // Add anti-aliasing mipmap contribution\n  vec3 dxy = max(abs(dFdx(sampleDir)), abs(dFdy(sampleDir)));\n  sigma += 0.5 * max(max(dxy.x, dxy.y), dxy.z);\n\n  float mip =\n      clamp(-log2(sigma), cubeUV_minMipLevel, cubeUV_maxMipLevel) + filterMip;\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif\n`;\n"]}