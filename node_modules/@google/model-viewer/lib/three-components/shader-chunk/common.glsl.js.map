{"version":3,"file":"common.glsl.js","sourceRoot":"","sources":["../../../src/three-components/shader-chunk/common.glsl.js"],"names":[],"mappings":"AAAA,OAAO,EAA2C,aAAa,EAAE,cAAc,EAA0C,YAAY,EAAE,YAAY,EAAE,cAAc,EAAE,aAAa,EAAE,YAAY,EAAwB,MAAM,OAAO,CAAC;AAEtO,OAAO,EAAC,gBAAgB,EAAC,MAAM,oCAAoC,CAAA;AAEnE,gFAAgF;AAChF,gFAAgF;AAChF,qDAAqD;AAErD,8EAA8E;AAC9E,8DAA8D;AAE9D,MAAM,CAAC,MAAM,iBAAiB,GAAG,UAAU,CAAC;;;;;;;;;;;;;;;;;;;;;;;;CAwB3C,CAAC;AAEF,MAAM,CAAC,MAAM,YAAY,GAAG,UAAU,CAAC;;;;;;;;;;;;;;;;;CAiBtC,CAAC;AAEF,MAAM,CAAC,MAAM,UAAU,GAAG,UAAU,CAAC;;;;;;;;;;;;;;;;;;CAkBpC,CAAC;AAEF,MAAM,CAAC,MAAM,SAAS,GAAG;IACvB,CAAC,cAAc,CAAC,EAAE,CAAC;IACnB,CAAC,YAAY,CAAC,EAAE,CAAC;IACjB,CAAC,YAAY,CAAC,EAAE,CAAC;IACjB,CAAC,aAAa,CAAC,EAAE,CAAC;IAClB,CAAC,cAAc,CAAC,EAAE,CAAC;IACnB,CAAC,YAAY,CAAC,EAAE,CAAC;IACjB,CAAC,aAAa,CAAC,EAAE,CAAC;CACnB,CAAC;AAEF,MAAM,CAAC,MAAM,OAAO,GAAG,UAAU,CAAC;;;EAGhC,gBAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmCjB,CAAC","sourcesContent":["import {ACESFilmicToneMapping, CineonToneMapping, GammaEncoding, LinearEncoding, LinearToneMapping, ReinhardToneMapping, RGBDEncoding, RGBEEncoding, RGBM16Encoding, RGBM7Encoding, sRGBEncoding, Uncharted2ToneMapping} from 'three';\n\nimport {texelConversions} from './encodings_pars_framgment.glsl.js'\n\n// These shader functions convert between the UV coordinates of a single face of\n// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n// sampling a textureCube (not generally normalized).\n\n// getDirectionChunk handles uv coordinates that are beyond [0, 1] in either x\n// or y (not both) by wrapping around to the neighboring face.\n\nexport const getDirectionChunk = /* glsl */ `\nvec3 getDirection(vec2 uv, int face) {\n    uv = 2.0 * uv - 1.0;\n    vec3 direction = vec3(clamp(uv, -1.0, 1.0), 1.0);\n    uv = abs(uv);\n    float over = max(uv.x, uv.y) - 1.0;\n    if(over > 0.0) direction.z -= over;\n    if (face == 0) {\n      direction = direction.zyx;\n      direction.z *= -1.0;\n    } else if (face == 1) {\n      direction = direction.xzy;\n      direction.z *= -1.0;\n    } else if (face == 3) {\n      direction = direction.zyx;\n      direction.x *= -1.0;\n    } else if (face == 4) {\n      direction = direction.xzy;\n      direction.y *= -1.0;\n    } else if (face == 5) {\n      direction.xz *= -1.0;\n    }\n    return direction;\n}\n`;\n\nexport const getFaceChunk = /* glsl */ `\nint getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    int face = -1;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0 : 3;\n      else\n        face = direction.y > 0.0 ? 1 : 4;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2 : 5;\n      else\n        face = direction.y > 0.0 ? 1 : 4;\n    }\n    return face;\n}\n`;\n\nexport const getUVChunk = /* glsl */ `\nvec2 getUV(vec3 direction, int face) {\n    vec2 uv;\n    if (face == 0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\n    } else if (face == 1) {\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\n    } else if (face == 2) {\n      uv = direction.xy / abs(direction.z);\n    } else if (face == 3) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\n    } else if (face == 4) {\n      uv = direction.xz / abs(direction.y);\n    } else {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\n    }\n    return 0.5 * (uv + 1.0);\n}\n`;\n\nexport const encodings = {\n  [LinearEncoding]: 0,\n  [sRGBEncoding]: 1,\n  [RGBEEncoding]: 2,\n  [RGBM7Encoding]: 3,\n  [RGBM16Encoding]: 4,\n  [RGBDEncoding]: 5,\n  [GammaEncoding]: 6\n};\n\nexport const texelIO = /* glsl */ `\nuniform int inputEncoding;\nuniform int outputEncoding;\n${texelConversions}\nvec4 inputTexelToLinear(vec4 value){\n    if(inputEncoding == 0){\n        return value;\n    }else if(inputEncoding == 1){\n        return sRGBToLinear(value);\n    }else if(inputEncoding == 2){\n        return RGBEToLinear(value);\n    }else if(inputEncoding == 3){\n        return RGBMToLinear(value, 7.0);\n    }else if(inputEncoding == 4){\n        return RGBMToLinear(value, 16.0);\n    }else if(inputEncoding == 5){\n        return RGBDToLinear(value, 256.0);\n    }else{\n        return GammaToLinear(value, 2.2);\n    }\n}\nvec4 linearToOutputTexel(vec4 value){\n    if(outputEncoding == 0){\n        return value;\n    }else if(outputEncoding == 1){\n        return LinearTosRGB(value);\n    }else if(outputEncoding == 2){\n        return LinearToRGBE(value);\n    }else if(outputEncoding == 3){\n        return LinearToRGBM(value, 7.0);\n    }else if(outputEncoding == 4){\n        return LinearToRGBM(value, 16.0);\n    }else if(outputEncoding == 5){\n        return LinearToRGBD(value, 256.0);\n    }else{\n        return LinearToGamma(value, 2.2);\n    }\n}\n`;"]}